#clear; #удаляет все переменные из текущего рабочего пространства, освобождая их из системной памяти.
clc; #очищает командное окно

n = 5;
A = zeros(n); #матрица n х n
f = zeros(n, 1); #матрица размера m х n
eye_mat = eye(n); #единичная матрица   

res = zeros(n); #матрица n х n 
#вычислить для произвольной матрицы обратную матрицу

#заполняем матрицу согласно условию варианта 9
for i = 1:n
    f(i) = 1/(n-i+1);
    for j = 1:n
        A(i, j) = (i + j)^3 / (i^2 + j^2);
    endfor
endfor

function [x, d] = Gauss (A,f)
    d = 1;
    [n, m] = size(A);
    x = zeros(n, 1);
    A(:, m + 1) = f; 
    #Считаем определитель матрицы
    for k = 1:n
        d = d * A(k, k); #Продолжая вычисления, находим d
        #1. Вынесем a(1,1) за знак определителя, предварительно разделив на него первую строку
        A(k, :) = A(k, :) / A(k, k); 
        for j = k + 1:m
            A(j, :) = A(j, :) - A(j, k) * A(k, :); #2. Из j-ой строки последнего определителя ( i >= 2) вычтем первую, умноженную на a(i,1)
        endfor
    endfor
    
    #С помощью метода Гаусса решить систему линейных алгебраических уравнений Ax=f.
   # Обратный ход метода Гаусса состоит в последовательном вычислении x(i), i=n,1 начиная с последнего, по следующим формулам
    f = A(:, m + 1);
    x(n) = f(n);
    for i = n-1:-1:1 
        x(i) = f(i) - A(i,i + 1:end - 1) * x(i+1:end);
    endfor
endfunction

[x, d] = Gauss(A, f);
x
A \ f #A\b solves the equation Ax = b .
d
det(A)  

#вычислить для произвольной матрицы обратную матрицу
#Для получения A^-1 , обратной к матрице A , можно воспользоваться тем фактом, что
#обратная матрица будет являться решением матричного уравнения: AX =E , где E-единичная матрица
#Каждое из уравнений может быть решено методом Гаусса. 
for i = 1:n
    [res(:, i), _] = Gauss(A, eye_mat(:, i)); #_ это чтобы от функции gauss мы не возвращали определитель,только х
endfor
res
inv(A)